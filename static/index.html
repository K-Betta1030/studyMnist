<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>手書き数字認識</title>
    <link rel="icon" type="image/png" sizes="16x16" href="/static/favicon.png">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="theme-color" content="#ffffff">
    
    <!-- BootstrapのCDN追加 -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">

    <style>
        .canvas-container {
            /* モバイルでも中央寄せを維持 */
            width: 100%;
            max-width: 400px; /* キャンバスの最大幅 */
            margin: 0 auto;
        }
        #canvas {
            border: 2px solid #343a40; /* 枠線を少し濃く */
            border-radius: 8px; /* 角を丸くする */
            
            /* レスポンシブ対応: 親要素の幅に合わせる */
            width: 100%;
            height: auto;
            aspect-ratio: 1 / 1; /* 常に正方形を維持 */
            
            touch-action: none; /* タッチスクリーンの誤動作防止 */
            cursor: crosshair;
        }
        #result {
            font-size: 2.5rem; /* 結果を大きく表示 */
            font-weight: bold;
            min-height: 4rem; /* 結果表示エリアの高さを確保 */
        }
    </style>
</head>
<body class="bg-light">
    <div class="container mt-4 mb-4">
        <div class="row justify-content-center">
            <!-- col-lg-6 (広い画面) -> col-md-8 (中間) -> col-12 (狭い画面) -->
            <div class="col-12 col-md-8 col-lg-6">
                
                <h2 class="text-center mb-4">手書き数字認識</h2>
                
                <!-- キャンバスコンテナ -->
                <div class="canvas-container shadow-sm bg-white p-3 rounded">
                    <canvas id="canvas" width="400" height="400"></canvas>
                </div>
                
                <!-- ボタンエリア -->
                <div class="d-grid gap-2 d-sm-flex justify-content-sm-center mt-4">
                    <button class="btn btn-primary btn-lg px-4 gap-3" id="predict-btn">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-cpu" viewBox="0 0 16 16">
                          <path d="M5 0a.5.5 0 0 1 .5.5V2h1V.5a.5.5 0 0 1 1 0V2h1V.5a.5.5 0 0 1 1 0V2h1V.5a.5.5 0 0 1 1 0V2A2.5 2.5 0 0 1 14 4.5h1.5a.5.5 0 0 1 0 1H14v1h1.5a.5.5 0 0 1 0 1H14v1h1.5a.5.5 0 0 1 0 1H14v1h1.5a.5.5 0 0 1 0 1H14A2.5 2.5 0 0 1 11.5 14v1.5a.5.5 0 0 1-1 0V14h-1v1.5a.5.5 0 0 1-1 0V14h-1v1.5a.5.5 0 0 1-1 0V14h-1v1.5a.5.5 0 0 1-1 0V14A2.5 2.5 0 0 1 2 11.5H.5a.5.5 0 0 1 0-1H2v-1H.5a.5.5 0 0 1 0-1H2v-1H.5a.5.5 0 0 1 0-1H2v-1H.5a.5.5 0 0 1 0-1H2A2.5 2.5 0 0 1 4.5 2V.5A.5.5 0 0 1 5 0m-.5 3A1.5 1.5 0 0 0 3 4.5v7A1.5 1.5 0 0 0 4.5 13h7a1.5 1.5 0 0 0 1.5-1.5v-7A1.5 1.5 0 0 0 11.5 3zM5 6.5A1.5 1.5 0 0 1 6.5 5h3A1.5 1.5 0 0 1 11 6.5v3A1.5 1.5 0 0 1 9.5 11h-3A1.5 1.5 0 0 1 5 9.5zM6.5 6a.5.5 0 0 0-.5.5v3a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 .5-.5v-3a.5.5 0 0 0-.5-.5z"/>
                        </svg>
                        認識
                    </button>
                    <button class="btn btn-outline-secondary btn-lg px-4" id="clear-btn">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-trash" viewBox="0 0 16 16">
                          <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0z"/>
                          <path d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4zM2.5 3h11V2h-11z"/>
                        </svg>
                        クリア
                    </button>
                </div>
                
                <!-- 結果表示エリア -->
                <div class="text-center mt-4 p-3 bg-white rounded shadow-sm">
                    <h5>認識結果</h5>
                    <p id="result" class="text-primary d-flex align-items-center justify-content-center">-</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 厳格モード
        'use strict';

        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('2d');
        const resultEl = document.getElementById('result');
        const predictBtn = document.getElementById('predict-btn');
        const clearBtn = document.getElementById('clear-btn');

        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        // キャンバスの初期化（背景を白で塗りつぶし）
        function initializeCanvas() {
            context.fillStyle = "white";
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // 線のスタイルを設定
            context.strokeStyle = 'black'; // 線の色
            context.lineWidth = 20;        // 線の太さ (解像度400pxに対して)
            context.lineJoin = 'round';    // 線の接合部を丸く
            context.lineCap = 'round';     // 線の先端を丸く
        }

        // 座標を取得（マウスとタッチ共通）
        function getCoordinates(e) {
            // タッチイベントの場合
            if (e.touches && e.touches.length > 0) {
                e.preventDefault(); // スクロールを防止
                const rect = canvas.getBoundingClientRect();
                return {
                    x: (e.touches[0].clientX - rect.left) * (canvas.width / rect.width),
                    y: (e.touches[0].clientY - rect.top) * (canvas.height / rect.height)
                };
            }
            // マウスイベントの場合
            const rect = canvas.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left) * (canvas.width / rect.width),
                y: (e.clientY - rect.top) * (canvas.height / rect.height)
            };
        }

        // 描画開始
        function startDrawing(e) {
            isDrawing = true;
            const { x, y } = getCoordinates(e);
            [lastX, lastY] = [x, y];
            context.beginPath(); // 新しいパスを開始
            context.moveTo(lastX, lastY);
        }

        // 描画中
        function draw(e) {
            if (!isDrawing) return;
            const { x, y } = getCoordinates(e);
            
            context.lineTo(x, y); // 線を引く
            context.stroke();     // 線を描画
            
            [lastX, lastY] = [x, y];
        }

        // 描画終了
        function stopDrawing() {
            if (!isDrawing) return;
            context.closePath(); // パスを閉じる
            isDrawing = false;
        }

        // キャンバスをクリア
        function clearCanvas() {
            console.log("キャンバスをクリアしました！");
            initializeCanvas();
            resultEl.textContent = '-'; // 結果をリセット
            predictBtn.disabled = false; // ボタンを再度有効化
        }

        // 予測を実行
        async function predictDigit() {
            console.log("認識ボタンがクリックされました！");
            resultEl.textContent = '認識中...';
            predictBtn.disabled = true;

            // モデルの入力サイズ(28x28)に合わせてキャンバスを縮小描画
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = 28;
            tempCanvas.height = 28;
            const tempCtx = tempCanvas.getContext('2d');
            
            // 元のキャンバス(400x400) -> 一時キャンバス(28x28) に縮小描画
            tempCtx.drawImage(canvas, 0, 0, 400, 400, 0, 0, 28, 28);
            
            // Base64データを取得 (JPEG形式)
            const imageData = tempCanvas.toDataURL("image/jpeg");

            console.log("28x28の画像データを取得しました。");

            try {
                const response = await fetch('/predict', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ imageData: imageData })
                });

                console.log("サーバーからのレスポンス:", response);
                
                if (!response.ok) {
                    throw new Error(`サーバーエラー: ${response.status}`);
                }

                const data = await response.json();

                console.log("サーバーからのデータ:", data);
                if (data.result) {
                    resultEl.textContent = data.result;
                } else if (data.error) {
                    resultEl.textContent = 'エラー';
                    console.error("予測エラー:", data.error);
                }
            } catch (error) {
                console.error("fetchエラー:", error);
                resultEl.textContent = '通信エラー';
            } finally {
                predictBtn.disabled = false; // ボタンを再度有効化
            }
        }

        // --- イベントリスナーの設定 ---

        // マウスイベント
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        
        // タッチイベント
        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchmove', draw);
        canvas.addEventListener('touchend', stopDrawing);
        canvas.addEventListener('touchcancel', stopDrawing);

        // ボタンイベント
        predictBtn.addEventListener('click', predictDigit);
        clearBtn.addEventListener('click', clearCanvas);

        // --- 初期化 ---
        initializeCanvas();
        console.log("手書き認識アプリが初期化されました。");

    </script>

    <!-- BootstrapのJS追加 -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>
